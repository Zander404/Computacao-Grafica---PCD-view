{% load static %}

<!-- Add this to the head section of your HTML template -->

<!-- <script type="module" src="{% static '/js/index.js' %}"></script> -->
<body>
  <style>

  </style>
  <div id="container" style="background-color: black;"></div>

  <div id="info">

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@v0.149.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@v0.149.0/examples/jsm/",
        "three/addons/": "https://unpkg.com/three@v0.149.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">

	import * as THREE from 'three';

	import Stats from 'three/addons/libs/stats.module.js';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
	import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
	import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';


	import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
    
    let scene = new THREE.Scene();
    
    scene.background = new THREE.Color( 0x444444 );

    let camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
    camera.position.set( 0, 1.6, 3 );
    camera.layers.enable( 1 );
    let renderer = new THREE.WebGLRenderer();
    let hand1, hand2;
		let controller1, controller2;
		let controllerGrip1, controllerGrip2;
    const tmpVector1 = new THREE.Vector3();
		const tmpVector2 = new THREE.Vector3();

    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    document.body.appendChild( VRButton.createButton( renderer ) );

    // // Controles
    // const controls = new OrbitControls(camera, renderer.domElement);
		// // controls.addEventListener("charge", render);
		// controls.minDistance = 5;
		// controls.maxDistance = 50;
		// controls.enablePan = true;

    let loader = new PLYLoader();
    // CONTROLE VR

    controller1 = renderer.xr.getController( 0 );
    scene.add( controller1 );

    controller2 = renderer.xr.getController( 1 );
    scene.add( controller2 );

    const controllerModelFactory = new XRControllerModelFactory();
    const handModelFactory = new XRHandModelFactory();

    // Hand 1
    controllerGrip1 = renderer.xr.getControllerGrip( 0 );
    controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
    scene.add( controllerGrip1 );

    hand1 = renderer.xr.getHand( 0 );
    hand1.addEventListener( 'pinchstart', onPinchStartLeft );
    hand1.addEventListener( 'pinchend', () => {

      scaling.active = false;

    } );
    hand1.add( handModelFactory.createHandModel( hand1 ) );

    scene.add( hand1 );

    // Hand 2
    controllerGrip2 = renderer.xr.getControllerGrip( 1 );
    controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
    scene.add( controllerGrip2 );

    hand2 = renderer.xr.getHand( 1 );
    hand2.addEventListener( 'pinchstart', onPinchStartRight );
    hand2.addEventListener( 'pinchend', onPinchEndRight );
    hand2.add( handModelFactory.createHandModel( hand2 ) );
    scene.add( hand2 );

    function onPinchStartLeft( event ) {

      const controller = event.target;

      if ( grabbing ) {

        const indexTip = controller.joints[ 'index-finger-tip' ];
        const sphere = collideObject( indexTip );

        if ( sphere ) {

          const sphere2 = hand2.userData.selected;
          console.log( 'sphere1', sphere, 'sphere2', sphere2 );
          if ( sphere === sphere2 ) {

            scaling.active = true;
            scaling.object = sphere;
            scaling.initialScale = sphere.scale.x;
            scaling.initialDistance = indexTip.position.distanceTo( hand2.joints[ 'index-finger-tip' ].position );
            return;

          }

        }

      }

      const geometry = new THREE.BoxGeometry( SphereRadius, SphereRadius, SphereRadius );
      const material = new THREE.MeshStandardMaterial( {
        color: Math.random() * 0xffff,
        roughness: 1.0,
        metalness: 0.0
      } );
      
      const spawn = new THREE.Mesh( geometry, material );
      spawn.geometry.computeBoundingSphere();

      const indexTip = controller.joints[ 'index-finger-tip' ];
      spawn.position.copy( indexTip.position );
      spawn.quaternion.copy( indexTip.quaternion );

      spheres.push( spawn );

      scene.add( spawn );

      }

      function collideObject( indexTip ) {

      for ( let i = 0; i < spheres.length; i ++ ) {

        const sphere = spheres[ i ];
        const distance = indexTip.getWorldPosition( tmpVector1 ).distanceTo( sphere.getWorldPosition( tmpVector2 ) );

        if ( distance < sphere.geometry.boundingSphere.radius * sphere.scale.x ) {

          return sphere;

        }

      }

      return null;

      }


    function onPinchStartRight( event ) {

      const controller = event.target;
      const indexTip = controller.joints[ 'index-finger-tip' ];
      const object = collideObject( indexTip );
      if ( object ) {

        grabbing = true;
        indexTip.attach( object );
        controller.userData.selected = object;
        console.log( 'Selected', object );

      }

      }

    function onPinchEndRight( event ) {

    const controller = event.target;

    if ( controller.userData.selected !== undefined ) {

      const object = controller.userData.selected;
      object.material.emissive.b = 0;
      scene.attach( object );

      controller.userData.selected = undefined;
      grabbing = false;

    }

    scaling.active = false;

    }
    const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, - 1 ) ] );

    const line = new THREE.Line( geometry );
    line.name = 'line';
    line.scale.z = 5;

    controller1.add( line.clone() );
    controller2.add( line.clone() );
    
    window.addEventListener( 'resize', onWindowResize );
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

    }
    
      
      // LUZES

    let ambientLight = new THREE.AmbientLight(0xffff)
    scene.add(ambientLight)

    let directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    scene.add(directionalLight);


    let rotationAngle = 0;

    renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.xr.enabled = true;
    container.appendChild( renderer.domElement );
    document.body.appendChild( VRButton.createButton( renderer ) );


    

    //
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    const files_path = "static/{{file_path}}"
    
    console.log(files_path)
    const file_extension = ".ply"
    const size = {{frames}}
    const scaling = {
				active: false,
				initialDistance: 0,
				object: null,
				initialScale: 1
			};

    let i = 0
    

    async function animate(){

        const file_name = files_path + i.toString().padStart(4,'0') + file_extension
        i += 1
        if (i == size){
            i=1
        }

       
        await loader.load(`${file_name}`, async function(geometry){


            const material = new THREE.PointsMaterial( { size: 0.01, vertexColors: true } );
            const mesh = new THREE.Points( geometry, material );

            mesh.position.y = -3.0;
            mesh.position.z = 0.3;
            mesh.rotation.x = -Math.PI / 2;
            mesh.scale.multiplyScalar(0.015);

            mesh.castShadow = true;
            mesh.receiveShadow = true;
        
            await scene.add(mesh);
            await sleep(20)
            await scene.remove(mesh);
        })

        await requestAnimationFrame(animate)
        if ( scaling.active ) {
          const indexTip1Pos = hand1.joints[ 'index-finger-tip' ].position;
          const indexTip2Pos = hand2.joints[ 'index-finger-tip' ].position;
          const distance = indexTip1Pos.distanceTo( indexTip2Pos );
          const newScale = scaling.initialScale + distance / scaling.initialDistance - 1;
          scaling.object.scale.setScalar( newScale );

        }

        await renderer.render(scene,camera)
    }
 
    await animate();

    

    


  </script>
</body>

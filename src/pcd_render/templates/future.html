{% load static %}

<!-- Add this to the head section of your HTML template -->

<!-- <script type="module" src="{% static '/js/index.js' %}"></script> -->
<body style="background-color: red;">
  <style>

  </style>

  <div id="container"></div>



  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@v0.149.0/build/three.module.js",
        "three/examples/jsm/": "https://unpkg.com/three@v0.149.0/examples/jsm/",
        "three/addons/": "https://unpkg.com/three@v0.149.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">

	import * as THREE from 'three';

	import Stats from 'three/addons/libs/stats.module.js';
	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { VRButton } from 'three/addons/webxr/VRButton.js';
	import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
	import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';


	import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
    
    // let scene = new THREE.Scene();
    // let camera
    
    // scene.background = new THREE.Color( 0x444444 );

    // camera = new THREE.PerspectiveCamera( 160, window.innerWidth / window.innerHeight, 1, 2000 );
    // // camera.layers.enable( 1 );
    // let renderer = new THREE.WebGLRenderer();
    // let hand1, hand2;
		// let controller1, controller2;
		// let controllerGrip1, controllerGrip2;
    // const tmpVector1 = new THREE.Vector3();
		// const tmpVector2 = new THREE.Vector3();

    // renderer.setSize(window.innerWidth, window.innerHeight);
    // document.body.appendChild(renderer.domElement);
    // document.body.appendChild( VRButton.createButton( renderer ) );

    // // Controles
    // const controls = new OrbitControls(camera, renderer.domElement);
		// // controls.addEventListener("charge", render);
		// controls.minDistance = 5;
		// controls.maxDistance = 50;
		// controls.enablePan = true;

    // let loader = new PLYLoader();
    // // CONTROLE VR

    // controller1 = renderer.xr.getController( 0 );
    // scene.add( controller1 );

    // controller2 = renderer.xr.getController( 1 );
    // scene.add( controller2 );

    // const controllerModelFactory = new XRControllerModelFactory();
    // const handModelFactory = new XRHandModelFactory();

    // // Hand 1
    // controllerGrip1 = renderer.xr.getControllerGrip( 0 );
    // controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
    // scene.add( controllerGrip1 );

    // hand1 = renderer.xr.getHand( 0 );
    // hand1.addEventListener( 'pinchstart', onPinchStartLeft );
    // hand1.addEventListener( 'pinchend', () => {

    //   scaling.active = false;

    // } );
    // hand1.add( handModelFactory.createHandModel( hand1 ) );

    // scene.add( hand1 );

    // // Hand 2
    // controllerGrip2 = renderer.xr.getControllerGrip( 1 );
    // controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
    // scene.add( controllerGrip2 );

    // hand2 = renderer.xr.getHand( 1 );
    // hand2.addEventListener( 'pinchstart', onPinchStartRight );
    // hand2.addEventListener( 'pinchend', onPinchEndRight );
    // hand2.add( handModelFactory.createHandModel( hand2 ) );
    // scene.add( hand2 );

    // function onPinchStartLeft( event ) {

    //   const controller = event.target;

    //   if ( grabbing ) {

    //     const indexTip = controller.joints[ 'index-finger-tip' ];
    //     const sphere = collideObject( indexTip );

    //     if ( sphere ) {

    //       const sphere2 = hand2.userData.selected;
    //       console.log( 'sphere1', sphere, 'sphere2', sphere2 );
    //       if ( sphere === sphere2 ) {

    //         scaling.active = true;
    //         scaling.object = sphere;
    //         scaling.initialScale = sphere.scale.x;
    //         scaling.initialDistance = indexTip.position.distanceTo( hand2.joints[ 'index-finger-tip' ].position );
    //         return;

    //       }

    //     }

    //   }

    //   const geometry = new THREE.BoxGeometry( SphereRadius, SphereRadius, SphereRadius );
    //   const material = new THREE.MeshStandardMaterial( {
    //     color: Math.random() * 0xffff,
    //     roughness: 1.0,
    //     metalness: 0.0
    //   } );
      
    //   const spawn = new THREE.Mesh( geometry, material );
    //   spawn.geometry.computeBoundingSphere();

    //   const indexTip = controller.joints[ 'index-finger-tip' ];
    //   spawn.position.copy( indexTip.position );
    //   spawn.quaternion.copy( indexTip.quaternion );

    //   spheres.push( spawn );

    //   scene.add( spawn );

    //   }

    //   function collideObject( indexTip ) {

    //   for ( let i = 0; i < spheres.length; i ++ ) {

    //     const sphere = spheres[ i ];
    //     const distance = indexTip.getWorldPosition( tmpVector1 ).distanceTo( sphere.getWorldPosition( tmpVector2 ) );

    //     if ( distance < sphere.geometry.boundingSphere.radius * sphere.scale.x ) {

    //       return sphere;

    //     }

    //   }

    //   return null;

    //   }


    // function onPinchStartRight( event ) {

    //   const controller = event.target;
    //   const indexTip = controller.joints[ 'index-finger-tip' ];
    //   const object = collideObject( indexTip );
    //   if ( object ) {

    //     grabbing = true;
    //     indexTip.attach( object );
    //     controller.userData.selected = object;
    //     console.log( 'Selected', object );

    //   }

    //   }

    // function onPinchEndRight( event ) {

    // const controller = event.target;

    // if ( controller.userData.selected !== undefined ) {

    //   const object = controller.userData.selected;
    //   object.material.emissive.b = 0;
    //   scene.attach( object );

    //   controller.userData.selected = undefined;
    //   grabbing = false;

    // }

    // scaling.active = false;

    // }
    // const geometry = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -1 ) ] );

    // const line = new THREE.Line( geometry );
    // line.name = 'line';
    // line.scale.z = 5;

    // controller1.add( line.clone() );
    // controller2.add( line.clone() );
    
    // window.addEventListener( 'resize', onWindowResize );

    
    // function onWindowResize() {
    //   camera.aspect = window.innerWidth / window.innerHeight;
    //   camera.updateProjectionMatrix();

    //   renderer.setSize( window.innerWidth, window.innerHeight );

    // }
    
      
    //   // LUZES

    // let ambientLight = new THREE.AmbientLight(0xffff)
    // scene.add(ambientLight)

    // let directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    // scene.add(directionalLight);

    
    // function sleep(ms) {
    //     return new Promise(resolve => setTimeout(resolve, ms));
    // }

    // const files_path = "static/{{file_path}}"
    
    // console.log(files_path)
    // const file_extension = ".ply"
    // const size = {{frames}}
    // const scaling = {
		// 		active: false,
		// 		initialDistance: 0,
		// 		object: null,
		// 		initialScale: 1
		// 	};

    // let i = 0
    

    // async function animate(){

    //     const file_name = files_path + i.toString().padStart(4,'0') + file_extension
    //     i += 1
    //     if (i == size){
    //         i=1
    //     }
    //     if (i >= 300){
    //       i = 0
    //     }
       
    //   await loader.load(`${file_name}`, async function(geometry){


    //       const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: true } );
    //       const mesh = new THREE.Points( geometry, material );



    //       mesh.castShadow = true;
    //       mesh.receiveShadow = true;
      
    //       await scene.add(mesh);
    //       await sleep(20)
    //       await scene.remove(mesh);
    //     })

    //     await requestAnimationFrame(animate)
    //     if ( scaling.active ) {
    //       const indexTip1Pos = hand1.joints[ 'index-finger-tip' ].position;
    //       const indexTip2Pos = hand2.joints[ 'index-finger-tip' ].position;
    //       const distance = indexTip1Pos.distanceTo( indexTip2Pos );
    //       const newScale = scaling.initialScale + distance / scaling.initialDistance - 1;
    //       scaling.object.scale.setScalar( newScale );

    //     }

    //     await renderer.render(scene,camera)
    // }
 
    // await animate();

      // let container, stats;
    
      // let i = 0

			// let camera, cameraTarget, scene, renderer, loader;

			// init();
			// animate();

			// function init() {
      //   // renderer

			// 	renderer = new THREE.WebGLRenderer( { antialias: true } );
			// 	renderer.setPixelRatio( window.devicePixelRatio );
			// 	renderer.setSize( window.innerWidth, window.innerHeight );
      //   // container = document.createElement( 'body' );
      //   // container.appendChild( renderer.domElement );
        
      //   renderer.xr.enabled = true;
      
			// 	renderer.shadowMap.enabled = true;
      //   // renderer.xr.setReferenceSpaceType( 'local' );
		  //   // container.appendChild( renderer.domElement );
		  //   document.body.appendChild( renderer.domElement );
      //   document.body.appendChild( VRButton.createButton( renderer ) );

        
 

			// 	camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			// 	camera.position.set( -5, 1.6, 3 );

			// 	cameraTarget = new THREE.Vector3( 0, - 0.1, 0 );
      //   camera.layers.enable( 1 );
			// 	scene = new THREE.Scene();
			// 	scene.background = new THREE.Color( 0xf880 );

      //   // Controles
      //   const controls = new OrbitControls(camera, renderer.domElement);
      //   // controls.addEventListener("charge", render);
      //   controls.minDistance = 5;
      //   controls.maxDistance = 50;
      //   controls.enablePan = true;


      //   loader = new PLYLoader()

     

			// 	// Lights

			// 	scene.add( new THREE.HemisphereLight( 0x8d7c7c, 0x494966, 3 ) );

			// 	// stats

			// 	// stats = new Stats();
			// 	// container.appendChild( stats.dom );

			// 	// resize

			// 	window.addEventListener( 'resize', onWindowResize );

			// }

			// function onWindowResize() {

			// 	camera.aspect = window.innerWidth / window.innerHeight;
			// 	camera.updateProjectionMatrix();
      //   camera.position.multiplyScalar(-1);
 

			// 	renderer.setSize( window.innerWidth, window.innerHeight );

			// }

			// async function animate() {

			// 	requestAnimationFrame( animate );

			// 	await render();
			// 	stats.update();

			// }

			// async function render() {

			// 	const timer = Date.now() * 50;

			// 	camera.lookAt( cameraTarget );

			// 	renderer.render( scene, camera );

      //   const files_path = "static/{{file_path}}"
      //   // console.log(files_path)
      //   const file_extension = ".ply"
      //   const size = {{frames}}
      //   const scaling = {
      //       active: false,
      //       initialDistance: 0,
      //       object: null,
      //       initialScale: 1
      //     };

    
			// 	const file_name = files_path + i.toString().padStart(4,'0') + file_extension
      //   i += 1
      //   if (i == size){
      //       i=0
      //   }

      //   async function sleep(ms) {
      //     return new Promise(resolve => setTimeout(resolve, ms*600));
      //   }
     
      //   loader.load(`${file_name}`, async function(geometry){
			// 		geometry.computeVertexNormals();

      //     const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: true } );
      //     const mesh = new THREE.Points( geometry, material );
      //     mesh.position.x = -0;
      //     mesh.position.y = -0.0;
      //     mesh.position.z =  0.0;

          
			// 		mesh.scale.multiplyScalar( 0.006 );
      //     mesh.matrixAutoUpdate = false;
      //     mesh.updateMatrix();
          
      //     var newTarget = new THREE.Vector3(0, 0, 0);
      //     newTarget.copy(mesh.position);
      //     camera.lookAt(newTarget);

      //     window.addEventListener( 'resize', onWindowResize );


			// 		mesh.castShadow = true;
			// 		mesh.receiveShadow = true;
          
			// 		scene.add( mesh );
      //     // await sleep(timer)
      //     await sleep(10)
      //     await scene.remove(mesh);
          
			// 	} );

			// }

  